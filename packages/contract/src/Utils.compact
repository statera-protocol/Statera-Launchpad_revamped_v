module Utils {

    import CompactStandardLibrary;
    import VariablesAndTypes;

    export circuit public_key(sk: Bytes<32>): Bytes<32> {
        return persistentHash<Vector<2, Bytes<32>>>([pad(32, "statera-launchpad:user-pk"), sk]);
    }

    export circuit generatePrivateStateHash(metadata: UserPrivateState, userPk: Bytes<32>): Bytes<32>{
        return persistentCommit<UserPrivateState>(
            metadata,
            userPk
        );
    }
    export circuit recieveFund(disclosedCoin: CoinInfo, disclosedSaleId: Uint<32>): []{
        receive(disclosedCoin);

        const pool = raisedTokenPools.lookup(disclosedSaleId);
        /** Update the ledger balance */
        const coinToInsert = pool.value > 0 ? 
            mergeCoinImmediate(pool, disclosedCoin) :
            disclosedCoin;

        raisedTokenPools.insertCoin(
            disclosedSaleId,
            coinToInsert,
            right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
        );
    }
    export circuit updateState(disclosedSaleId: Uint<32>, saleInfo: SaleInfo, disclosedCoinAmount: Uint<128>, userPk: Bytes<32>, current_time: Uint<64>):[] {
        const funder = public_key(disclose(local_secret_key()));
        const allocation = disclose(calculate_total_allocation(saleInfo.exchangeRatio, saleInfo.slope, disclosedCoinAmount, saleInfo.totalTokenSold));
        const hasContributedBefore = disclose(confirm_sale_in_private_state(disclosedSaleId));
        if (hasContributedBefore) {
            const funderPrivateState = disclose(get_user_private_state_hash(disclosedSaleId));
                
            const updatedPrivateState = UserPrivateState {
                ...funderPrivateState,
                contribution: funderPrivateState.contribution + disclosedCoinAmount as Uint<64>,
                totalAllocation: funderPrivateState.totalAllocation + allocation as Uint<64>
            };

            update_user_private_state(updatedPrivateState, disclosedSaleId);

            const userPrivateStateHash = generatePrivateStateHash(updatedPrivateState, userPk);

            fundingInfo.insert(funder, FundingInfo {
                privateStateHash: userPrivateStateHash,
                claimComplete: false
            });
        } else {
            const newPrivateState = UserPrivateState {
                saleId: disclosedSaleId,
                contribution: disclosedCoinAmount,
                totalAllocation: allocation,
                claimedAllocation: 0
            };

            update_user_private_state(newPrivateState, disclosedSaleId);

            const userPrivateStateHash = generatePrivateStateHash(newPrivateState, userPk);

            fundingInfo.insert(funder, FundingInfo {
                privateStateHash: userPrivateStateHash,
                claimComplete: false
            });

        }
        contractSalesInfo.insert(disclosedSaleId, SaleInfo {
            ...saleInfo,
            participants: hasContributedBefore ? saleInfo.participants : (saleInfo.participants + 1) as Uint<16>,
            amountRaised: disclosedCoinAmount + saleInfo.amountRaised as Uint<64>,
            totalTokenSold: allocation + saleInfo.totalTokenSold as Uint<64>,
            phase: saleInfo.saleModel == Model.Fixed ?
                saleInfo.amountRaised == saleInfo.target || saleInfo.endTime < current_time ? SalePhase.Ended : SalePhase.Live : 
                current_time > saleInfo.endTime ? SalePhase.Ended : SalePhase.Live,
        });
    }
}