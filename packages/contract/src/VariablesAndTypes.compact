module VariablesAndTypes {
    import CompactStandardLibrary;

    /** Exports the types and ledger variables **/
    export { SaleInfo, raisedTokenPool, superAdmin, contractSalesInfo, TVL, Sale, organizerPubKey, uniqueIndex, nonce, allowedUser, UserPrivateState, FundingInfo, fundingInfo, SCALE_FACTOR, TokenSold, saleId };

    /** Once contract is deployed, the contract receives a specified amount of token which will be minted on the token contract provided by the organizers **/
    ledger TVL: QualifiedCoinInfo; /** Holds token to be disbursed to investors - We expect that there would be token in the TVL before sale is being created **/
    ledger TokenSold: Uint<64>;
    ledger raisedTokenPool: QualifiedCoinInfo; // Holds token invested by investors
    sealed ledger organizerPubKey: ZswapCoinPublicKey; // Receives the funds raised contributed by investors
    sealed ledger superAdmin: Bytes<32>; // There will be one super admin, who instantiate new token sale and add or remove other admins
    ledger allowedUser: Set<Bytes<32>>; // contains list of eligible users - in the allowed list
    ledger contractSalesInfo: Map<Uint<64>, SaleInfo>; /** Keeps record of contract information **/
    ledger fundingInfo: Map<Bytes<32>, FundingInfo>; /** Keeps record of contract information **/
    sealed ledger SCALE_FACTOR: Uint<32>; // 1_000_000 subunit per assets
    ledger uniqueIndex: Counter;
    ledger saleId: Counter;
    ledger nonce: Bytes<32>;

    enum Sale { Public, Private };

    struct SaleInfo {
        target: Uint<64>;
        startTime: Uint<64>;
        endTime: Uint<64>;
        totalTokenAmount: Uint<128>;
        totalTokenSold: Uint<64>;
        saleInfoCID: Bytes<32>;
        amountRaised: Uint<64>;
        acceptableExchangeToken: Bytes<32>;
        hasEnded: Boolean;
        min: Uint<64>;
        max: Uint<64>;
        participants: Uint<16>;
        organizer: Bytes<32>;
        hasWithdrawn: Boolean;
        exchangeRatio: Uint<64>;
        saleType: Sale;
        slope: Uint<32>;
        tgeAllocationPercentage: Uint<8>;
        vestingPeriod: Uint<64>;
        vestClaimPercentagePerDay: Uint<8>;
    };

    struct FundingInfo {
        privateStateHash: Bytes<32>; // hash of user private state. To validate user private state 
        claimComplete: Boolean; // checks if user has claimed allocation already
    }

    struct UserPrivateState {
        saleId: Uint<32>;
        contribution: Uint<128>;
        totalAllocation: Uint<64>;
        claimedAllocation: Uint<64>;
    }
        
    // WITNESSES
    export witness local_secret_key(): Bytes<32>;
    export witness generate_sale_id(): Bytes<32>;
    export witness get_current_time(): Uint<64>;
    export witness calculate_total_allocation(ratio: Uint<64>, price_slope: Uint<32>, contribution: Uint<128>, token_sold: Uint<64> ): Uint<64>;
    export witness update_user_private_state(new_private_state: UserPrivateState, saleId: Uint<32>) :[];
    export witness confirm_sale_in_private_state(saleId: Uint<32>) :Boolean;
    export witness get_user_private_state_hash(sale_id: Uint<32>) :UserPrivateState;
    export witness remove_sale_from_private_state(sale_id: Uint<32>) :[];
    export witness calculate_vest_claim_percentage_per_day(vesting_duration: Uint<64>, tge_allocation_percentage: Uint<8>):Uint<8>;
    export witness calculate_total_vest_claim(claim_per_day_percentage: Uint<8>, end_time: Uint<64>, totalAllocation: Uint<64>, claimedAllocation: Uint<64>): Uint<64>;
    export witness calculate_claim_amount(percentage: Uint<8>, total_allocation: Uint<64>): Uint<64>;
    export witness calculate_deduction(sale_id: Uint<32>, refund_amount: Uint<64>): Uint<64>;
}