module SalesManager {
    import CompactStandardLibrary;
    import VariablesAndTypes;
    import Utils;

    export { createSale, fundSale, claimTokens, refund, receiveFundsRaised };

    circuit createSale(
        start_price: Uint<64>, 
        total_amount: Uint<64>,
        exchange_token: Bytes<32>, 
        end_time: Uint<64>, 
        min: Uint<64>, 
        max: Uint<64>, 
        infoCID: Bytes<32>, 
        price_slope: Uint<32>, 
        isPrivate: Boolean, 
        tge_allocation_percentage: Uint<8>,
        vesting_duration: Uint<64> 
    ) :[] {
        assert(disclose(start_price) > 0, "Sale ratio must be greater than 0!");
        assert(disclose(total_amount) > 0 && disclose(total_amount) <= TVL.value, "Sale amount must be greater than 0!");
        const leftOver = TVL.value == TokenSold || TVL.value < TokenSold ? 0 : TVL.value - TokenSold;
        assert(leftOver >= disclose(total_amount), "No enough token to create another sale");
        const organizer = public_key(disclose(local_secret_key()));
        saleId.increment(1);

        const current_time = disclose(get_current_time());
        
        const claimPercentage = disclose(vesting_duration) == 0 ? 100 : disclose(calculate_vest_claim_percentage_per_day(disclose(vesting_duration), disclose(tge_allocation_percentage)));

        TokenSold = disclose(total_amount) + TokenSold as Uint<64>;
        contractSalesInfo.insert(saleId, SaleInfo {
            target: disclose(total_amount) * disclose(start_price) as Uint<64>, 
            startTime: disclose(current_time),
            endTime: disclose(end_time),
            totalTokenAmount: disclose(total_amount),
            totalTokenSold: 0,
            saleInfoCID: disclose(infoCID),
            amountRaised: 0,
            acceptableExchangeToken: disclose(exchange_token),
            hasEnded: false,
            min: disclose(min),
            max: disclose(max),
            participants: 0,
            organizer: default<Bytes<32>>, 
            hasWithdrawn: false, 
            exchangeRatio: disclose(start_price), 
            saleType: disclose(isPrivate) ?  Sale.Private : Sale.Public,
            slope: disclose(price_slope), 
            tgeAllocationPercentage: disclose(tge_allocation_percentage),
            vestingPeriod: disclose(vesting_duration),
            vestClaimPercentagePerDay: claimPercentage
        });
    }

    circuit fundSale(coin: CoinInfo, sale_id: Uint<32>) :[] {
        const disclosedCoin = disclose(coin);
        const disclosedCoinAmount = disclosedCoin.value;
        const disclosedSaleId = disclose(sale_id);
        assert(contractSalesInfo.member(disclosedSaleId), "This sale doesn't exist");
        
        const userPk = ownPublicKey().bytes; 
        const funder = public_key(disclose(local_secret_key()));
        const saleInfo = contractSalesInfo.lookup(disclosedSaleId);
        const current_time = disclose(get_current_time());
        assert(saleInfo.startTime < current_time, "Sale is yet to begin");
        
        saleInfo.saleType == Sale.Private && assert(allowedUser.member(userPk), "You are not eligible for this sale");
        assert(!saleInfo.hasEnded, "This sale has ended");
        assert(saleInfo.acceptableExchangeToken == disclosedCoin.color, "Please provided the acceptable token");
        assert(disclosedCoinAmount <= saleInfo.max && disclosedCoinAmount >= saleInfo.min, "Amount entered breaches did not fall within threshold");
        assert(saleInfo.amountRaised < saleInfo.target, "Sale target has already been achieved");

        recieveFund(disclosedCoin);
        const allocation = disclose(calculate_total_allocation(saleInfo.exchangeRatio, saleInfo.slope, disclosedCoinAmount, saleInfo.totalTokenSold));

        const hasContributedBefore = disclose(confirm_sale_in_private_state(disclosedSaleId));
        if (hasContributedBefore) {
            const funderPrivateState = disclose(get_user_private_state_hash(disclosedSaleId));
                
            const updatedPrivateState = UserPrivateState {
                ...funderPrivateState,
                contribution: funderPrivateState.contribution + disclosedCoinAmount as Uint<64>,
                totalAllocation: funderPrivateState.totalAllocation + allocation as Uint<64>
            };

            update_user_private_state(updatedPrivateState, disclosedSaleId);

            const userPrivateStateHash = generatePrivateStateHash(updatedPrivateState, userPk);

            fundingInfo.insert(funder, FundingInfo {
                privateStateHash: userPrivateStateHash,
                claimComplete: false
            });
            
            contractSalesInfo.insert(disclosedSaleId, SaleInfo {
                ...saleInfo,
                hasEnded: current_time > saleInfo.endTime,
                amountRaised: disclosedCoinAmount + saleInfo.amountRaised as Uint<64>,
                totalTokenSold: allocation + saleInfo.totalTokenSold as Uint<64>,
            });
        } else {
            const newPrivateState = UserPrivateState {
                saleId: disclosedSaleId,
                contribution: disclosedCoinAmount,
                totalAllocation: allocation,
                claimedAllocation: 0
            };

            update_user_private_state(newPrivateState, disclosedSaleId);

            const userPrivateStateHash = generatePrivateStateHash(newPrivateState, userPk);

            fundingInfo.insert(funder, FundingInfo {
                privateStateHash: userPrivateStateHash,
                claimComplete: false
            });

            contractSalesInfo.insert(disclosedSaleId, SaleInfo {
                ...saleInfo,
                hasEnded: current_time > saleInfo.endTime,
                participants: (saleInfo.participants + 1) as Uint<16>,
                amountRaised: disclosedCoinAmount + saleInfo.amountRaised as Uint<64>,
                totalTokenSold: allocation + saleInfo.totalTokenSold as Uint<64>,
            });
        }
    }
    
    circuit claimTokens(sale_id: Uint<32>):[] {
        const disclosedSaleId = disclose(sale_id);
        
        const userPk = ownPublicKey().bytes;
        assert(contractSalesInfo.member(disclosedSaleId), "Sale does not exist");
        const saleInfo = contractSalesInfo.lookup(disclosedSaleId);
        // assert(saleInfo.hasEnded, "Can't claim token until sale is over");

        const funderPk = public_key(disclose(local_secret_key()));
        assert(fundingInfo.member(funderPk), "You did not participate in this sale");
        const funderOnchainInfo = fundingInfo.lookup(funderPk);
        
        const funderPrivateState = disclose(get_user_private_state_hash(disclosedSaleId));
        const funderPrivateStateHash = generatePrivateStateHash(funderPrivateState, userPk);
        assert(funderPrivateStateHash == funderOnchainInfo.privateStateHash, "Private state and onchain state mismatch");
        assert(funderOnchainInfo.claimComplete == false, "you have already claimed your token");
        
        const current_time = disclose(get_current_time());

        const vestClaimAmount = saleInfo.vestClaimPercentagePerDay == 100 ? funderPrivateState.totalAllocation : disclose(calculate_total_vest_claim(saleInfo.vestClaimPercentagePerDay, saleInfo.endTime, funderPrivateState.totalAllocation, funderPrivateState.claimedAllocation));
        assert(vestClaimAmount > 0, "No tokens available to claim at this time");

        const sendResult = send(TVL, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()), vestClaimAmount);
    
        if(sendResult.change.is_some){
            TVL.writeCoin(
                sendResult.change.value,
                right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
            );
        }else{
            TVL.resetToDefault();
        }
        
        const newPrivateState = UserPrivateState {
            ...funderPrivateState,
            claimedAllocation: funderPrivateState.claimedAllocation + vestClaimAmount as Uint<64>
        };
        update_user_private_state(newPrivateState, disclosedSaleId);

        const newFunderPrivateStateHash = generatePrivateStateHash(newPrivateState, userPk);
        fundingInfo.insert(funderPk, FundingInfo {
            privateStateHash: newFunderPrivateStateHash, 
            claimComplete: newPrivateState.claimedAllocation == newPrivateState.totalAllocation 
        });
    }

    export circuit refund(sale_id: Uint<32>, refundAmount: Uint<64>): [] {
        const disclosedSaleId = disclose(sale_id);
        const disclosedRefundAmount = disclose(refundAmount);
        const userPk = ownPublicKey().bytes;
        assert(contractSalesInfo.member(disclosedSaleId), "Sale does not exist");
        const saleInfo = contractSalesInfo.lookup(disclosedSaleId);
        assert(!saleInfo.hasEnded, "Sale is over can't apply for a refund");

        const funder = public_key(disclose(local_secret_key()));
        
        const hasContributed = disclose(confirm_sale_in_private_state(disclosedSaleId));
        assert(hasContributed, "You didn't participate in this sale");
        assert(fundingInfo.member(funder), "Data not found onchain");
        const funderOnchainInfo = fundingInfo.lookup(funder);
        
        const funderPrivateState = disclose(get_user_private_state_hash(disclosedSaleId));
        const funderPrivateStateHash = generatePrivateStateHash(funderPrivateState, userPk);
        // assert(funderPrivateStateHash == funderOnchainInfo.privateStateHash, "Private state and onchain state mismatch");
        assert(funderPrivateState.contribution >= disclosedRefundAmount, "Refund amount can not be greater than contribution");

        const deduct = disclose(calculate_deduction(disclosedSaleId, disclosedRefundAmount));

        if (funderPrivateState.contribution == disclosedRefundAmount) {
            remove_sale_from_private_state(disclosedSaleId);
            fundingInfo.remove(funder);
        } else {
            const newPrivateState = UserPrivateState {
                ...funderPrivateState,
                contribution: funderPrivateState.contribution - disclosedRefundAmount,
                totalAllocation: funderPrivateState.totalAllocation - deduct,
            };
            update_user_private_state(newPrivateState, disclosedSaleId);
    
            const userPrivateStateHash = generatePrivateStateHash(newPrivateState, userPk); 
        
            fundingInfo.insert(funder, FundingInfo {
                privateStateHash: userPrivateStateHash,
                claimComplete: false
            });
        }
        
        contractSalesInfo.insert(disclosedSaleId, SaleInfo {
            ...saleInfo,
            amountRaised: saleInfo.amountRaised - disclosedRefundAmount,
            totalTokenSold: saleInfo.totalTokenSold - deduct
        });

        const sendResult = send(raisedTokenPool, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()), disclosedRefundAmount);

        if(sendResult.change.is_some){
            raisedTokenPool.writeCoin(
                sendResult.change.value,
                right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
            );
        } else {
            raisedTokenPool.resetToDefault();
        }
    }

    export circuit receiveFundsRaised(sale_id: Uint<32>) :[] {
        const disclosedSaleId = disclose(sale_id);
        assert(contractSalesInfo.member(disclosedSaleId), "Sale does not exist");  
        const saleInfo = contractSalesInfo.lookup(disclosedSaleId);
        assert(!saleInfo.hasEnded, "Sale is over can't receive funds yet");
        assert(!saleInfo.hasWithdrawn, "Funds has been withdrawn from this sale");
        assert(raisedTokenPool.value > 0, "No tokens left in this pool");
        assert(saleInfo.amountRaised > 0, "No token raised from this sale");
        const userPk = ownPublicKey().bytes; 
        assert(userPk == organizerPubKey.bytes, "You are not the organizer");

        const sendResult = send(raisedTokenPool, left<ZswapCoinPublicKey, ContractAddress>(organizerPubKey), saleInfo.amountRaised);

        if(sendResult.change.is_some){
            raisedTokenPool.writeCoin(
                sendResult.change.value,
                right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
            );
        }else{
            raisedTokenPool.resetToDefault();
        }
        contractSalesInfo.insert(disclosedSaleId, SaleInfo {
            ...saleInfo,
            hasWithdrawn: true,
        });
    }
}
