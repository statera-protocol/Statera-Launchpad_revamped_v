module SalesManager {
    import CompactStandardLibrary;
    import VariablesAndTypes;
    import Utils;

    export { createSale, fundSale, claimTokens, refund, receiveFundsRaised };
    /**This same circuit can be used for BATCH, FIXED, FCFS,  **/

    circuit createSale(
        start_price: Uint<64>, // The (start) price of a token
        total_amount: Uint<64>, // The total amount of token to be sold in this particular sale
        exchange_token: Bytes<32>, // The token color of the exchange token - token to be received
        end_time: Uint<64>, // The time which a sale ends
        min: Uint<64>, // Min amount of token a user can buy 
        max: Uint<64>, // Max amount of token a user can buy 
        infoCID: Bytes<32>, // CID that points to other informatin about sale on ipfs
        price_slope: Uint<32>, // influences the price, if it is a dynamic price sale
        isPrivate: Boolean, 
        cliff_period: Uint<64>, // the period whcih the token will be completely locked
        tge_period: Uint<64>,
        tge_allocation_percentage: Uint<8>, // the percentage that should be withdrawn at TGE
        vesting_duration: Uint<64> 
    ) :[] {
        assert(disclose(start_price) > 0, "Sale ratio must be greater than 0!");
        /** Asserts that the total amount of token to be sold is not beyond the amount locked in the contract **/
        assert(disclose(total_amount) > 0 && disclose(total_amount) <= TVL.value, "Sale amount must be greater than 0!");
        const leftOver = TVL.value == TokenSold || TVL.value < TokenSold ? 0 : TVL.value - TokenSold;
        assert(leftOver >= disclose(total_amount), "No enough token to create another sale");
        const organizer = public_key(disclose(local_secret_key()));
        // const saleId = disclose(generate_sale_id());
        saleId.increment(1);

        const current_time = disclose(get_current_time());
        
        /** Calculates vesting amount per day - returns full amount if vesting period is 0 **/
        const claimPercentage = disclose(vesting_duration) == 0 ? 100 : disclose(calculate_vest_claim_percentage_per_day(disclose(vesting_duration), disclose(tge_allocation_percentage)));

        TokenSold = disclose(total_amount) + TokenSold as Uint<64>;
        /** stores information about sales **/
        contractSalesInfo.insert(saleId, SaleInfo {
            target: disclose(total_amount) * disclose(start_price) as Uint<64>, 
            startTime: disclose(current_time),
            endTime: disclose(end_time),
            totalTokenAmount: disclose(total_amount),
            totalTokenSold: 0,
            saleInfoCID: disclose(infoCID),
            amountRaised: 0,
            acceptableExchangeToken: disclose(exchange_token),
            hasEnded: false,
            min: disclose(min),
            max: disclose(max),
            participants: 0,
            organizer: default<Bytes<32>>, 
            hasWithdrawn: false, // tracks wether or not investor has withdrawn or not
            exchangeRatio: disclose(start_price), // fixed price for token to be sold
            saleType: disclose(isPrivate) ?  Sale.Private : Sale.Public,
            slope: disclose(price_slope), // the dynamic increment for token price per token sold
            tgePeriod: disclose(tge_period), // marks the period when token distribution/generation begins
            tgeAllocationPercentage: disclose(tge_allocation_percentage),
            cliffPeriod: disclose(tge_period) + disclose(cliff_period) as Uint<64>,
            vestingPeriod: disclose(vesting_duration),
            vestClaimPercentagePerDay: claimPercentage
        });
    }

    circuit fundSale(coin: CoinInfo, sale_id: Uint<32>) :[] {
        /** Disclosing parameters for better code readability **/
        const disclosedCoin = disclose(coin);
        const disclosedCoinAmount = disclosedCoin.value;
        const disclosedSaleId = disclose(sale_id);
        assert(contractSalesInfo.member(disclosedSaleId), "This sale doesn't exist");
        /** ownPublicKey, which is unique is used to create commit hash for user Private State **/
        const userPk = ownPublicKey().bytes; 
        const funder = public_key(disclose(local_secret_key()));
        const saleInfo = contractSalesInfo.lookup(disclosedSaleId);
        const current_time = disclose(get_current_time());
        assert(saleInfo.startTime < current_time, "Sale is yet to begin");
        
        saleInfo.saleType == Sale.Private && assert(allowedUser.member(userPk), "You are not eligible for this sale");
        assert(!saleInfo.hasEnded, "This sale has ended");
        assert(saleInfo.acceptableExchangeToken == disclosedCoin.color, "Please provided the acceptable token");
        assert(disclosedCoinAmount <= saleInfo.max && disclosedCoinAmount >= saleInfo.min, "Amount entered breaches did not fall within threshold");
        assert(saleInfo.amountRaised < saleInfo.target, "Sale target has already been achieved");

        /** receives the token **/
        recieveFund(disclosedCoin);
        const allocation = disclose(calculate_total_allocation(saleInfo.exchangeRatio, saleInfo.slope, disclosedCoinAmount, saleInfo.totalTokenSold));

        const hasContributedBefore = disclose(confirm_sale_in_private_state(disclosedSaleId));
        if (hasContributedBefore) {
            const funderPrivateState = disclose(get_user_private_state_hash(disclosedSaleId));
                
            const updatedPrivateState = UserPrivateState {
                ...funderPrivateState,
                contribution: funderPrivateState.contribution + disclosedCoinAmount as Uint<64>,
                totalAllocation: funderPrivateState.totalAllocation + allocation as Uint<64>
            };

            update_user_private_state(updatedPrivateState, disclosedSaleId);

            /** we hash the user's private state witht userPk= **/
            const userPrivateStateHash = generatePrivateStateHash(updatedPrivateState, userPk);

            fundingInfo.insert(funder, FundingInfo {
                /** stores the hash of user's private state for validity check during claim **/
                privateStateHash: userPrivateStateHash,
                claimComplete: false
            });
            /** Updating contract state **/
            contractSalesInfo.insert(disclosedSaleId, SaleInfo {
                ...saleInfo,
                hasEnded: current_time > saleInfo.endTime,
                amountRaised: disclosedCoinAmount + saleInfo.amountRaised as Uint<64>,
                totalTokenSold: allocation + saleInfo.totalTokenSold as Uint<64>,
            });
        } else {
            const newPrivateState = UserPrivateState {
                saleId: disclosedSaleId,
                contribution: disclosedCoinAmount,
                totalAllocation: allocation,
                claimedAllocation: 0
            };
            /** adds the newPrivateState to existing private state **/
            update_user_private_state(newPrivateState, disclosedSaleId);

            /** we hash the user's private state witht userPk= **/
            const userPrivateStateHash = generatePrivateStateHash(newPrivateState, userPk);

            fundingInfo.insert(funder, FundingInfo {
                /** stores the hash of user's private state for validity check during claim **/
                privateStateHash: userPrivateStateHash,
                claimComplete: false
            });

            /** Updating contract state **/
            contractSalesInfo.insert(disclosedSaleId, SaleInfo {
                ...saleInfo,
                hasEnded: current_time > saleInfo.endTime,
                participants: (saleInfo.participants + 1) as Uint<16>,
                amountRaised: disclosedCoinAmount + saleInfo.amountRaised as Uint<64>,
                totalTokenSold: allocation + saleInfo.totalTokenSold as Uint<64>,
            });
        }
    }
    
    circuit claimTokens(sale_id: Uint<32>):[] {
        const disclosedSaleId = disclose(sale_id);
        /** ownPublicKey, which is unique is used to create commit hash for user Private State **/
        const userPk = ownPublicKey().bytes;
        assert(contractSalesInfo.member(disclosedSaleId), "Sale does not exist");
        const saleInfo = contractSalesInfo.lookup(disclosedSaleId);
        assert(saleInfo.hasEnded, "Can't claim token until sale is over");

        const funderPk = public_key(disclose(local_secret_key()));
        assert(fundingInfo.member(funderPk), "You did not not participate in this sale");
        const funderOnchainInfo = fundingInfo.lookup(funderPk);
        
        const funderPrivateState = disclose(get_user_private_state_hash(disclosedSaleId));
        const funderPrivateStateHash = generatePrivateStateHash(funderPrivateState, userPk); // we hash the user's private state witht userPk=
        assert(funderPrivateStateHash == funderOnchainInfo.privateStateHash, "Private state and onchain state mismatch");
        assert(funderOnchainInfo.claimComplete == false, "you have already claimed your token");
        
        const current_time = disclose(get_current_time());

        if (saleInfo.cliffPeriod > current_time) {
            const claimAmount = disclose(calculate_claim_amount(saleInfo.tgeAllocationPercentage, funderPrivateState.totalAllocation));
            assert(funderPrivateState.claimedAllocation < claimAmount, "Can't claim now!. Cliff period is on!");

            /** If user claim is lesser than the tge claim amount and cliff period is on, they can claim tge allocation*/
            const sendResult = send(TVL, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()), claimAmount);
        
            if(sendResult.change.is_some){
                TVL.writeCoin(
                    sendResult.change.value,
                    right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
                );
            }else{
                TVL.resetToDefault();
            }
            
            const newPrivateState = UserPrivateState {
                ...funderPrivateState,
                claimedAllocation: funderPrivateState.claimedAllocation + claimAmount as Uint<64>
            };
            update_user_private_state(newPrivateState, disclosedSaleId);

            const newFunderPrivateStateHash = generatePrivateStateHash(newPrivateState, userPk); // we hash the user's private state witht userPk=
            fundingInfo.insert(funderPk, FundingInfo {
                privateStateHash: newFunderPrivateStateHash, // stores the hash of user's private state for validity check during claim
                claimComplete: newPrivateState.claimedAllocation == newPrivateState.totalAllocation as Uint<64>
            });
        } else {
            const vestClaimAmount = disclose(calculate_total_vest_claim(saleInfo.vestClaimPercentagePerDay, saleInfo.cliffPeriod, funderPrivateState.totalAllocation, funderPrivateState.claimedAllocation));

            const sendResult = send(TVL, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()), vestClaimAmount);
            assert(vestClaimAmount > 0, "No tokens available to claim at this time");
        
            if(sendResult.change.is_some){
                TVL.writeCoin(
                    sendResult.change.value,
                    right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
                );
            }else{
                TVL.resetToDefault();
            }
            
            const newPrivateState = UserPrivateState {
                ...funderPrivateState,
                claimedAllocation: funderPrivateState.claimedAllocation + vestClaimAmount as Uint<64>
            };
            update_user_private_state(newPrivateState, disclosedSaleId);

            const newFunderPrivateStateHash = generatePrivateStateHash(newPrivateState, userPk); // we hash the user's private state witht userPk=
            fundingInfo.insert(funderPk, FundingInfo {
                privateStateHash: newFunderPrivateStateHash, // stores the hash of user's private state for validity check during claim
                claimComplete: newPrivateState.claimedAllocation == newPrivateState.totalAllocation 
            });
        }
    }

    export circuit refund(sale_id: Uint<32>, refundAmount: Uint<64>): [] {
        const disclosedSaleId = disclose(sale_id);
        const disclosedRefundAmount = disclose(refundAmount);
        const userPk = ownPublicKey().bytes;  // ownPublicKey, which is unique is used to create commit hash for user Private State
        assert(contractSalesInfo.member(disclosedSaleId), "Sale does not exist");
        const saleInfo = contractSalesInfo.lookup(disclosedSaleId);
        assert(!saleInfo.hasEnded, "Sale is over can't apply for a refund");

        const funder = public_key(disclose(local_secret_key()));
        
        // checks to validate user participation in the sale - checking and comparing hashed onchain and raw local data
        const hasContributed = disclose(confirm_sale_in_private_state(disclosedSaleId));
        assert(hasContributed, "You didn't participate in this sale");
        // assert(fundingInfo.member(funder), "Data not found onchain");
        const funderOnchainInfo = fundingInfo.lookup(funder);
        
        const funderPrivateState = disclose(get_user_private_state_hash(disclosedSaleId));
        const funderPrivateStateHash = generatePrivateStateHash(funderPrivateState, userPk); // we hash the user's private state witht userPk=
        // assert(funderPrivateStateHash == funderOnchainInfo.privateStateHash, "Private state and onchain state mismatch");
        assert(funderPrivateState.contribution >= disclosedRefundAmount, "Refund can not be greater than contribution");

        if(funderPrivateState.contribution > disclosedRefundAmount) {
            const sendResult = send(raisedTokenPool, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()), disclosedRefundAmount);

            if(sendResult.change.is_some){
                raisedTokenPool.writeCoin(
                    sendResult.change.value,
                    right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
                );
            } else {
                raisedTokenPool.resetToDefault();
            }

            // theres an error here!
            const contribution = funderPrivateState.contribution - disclosedRefundAmount;
            const newAllocation = disclose(calculate_total_allocation(saleInfo.exchangeRatio, saleInfo.slope, contribution, saleInfo.totalTokenSold));
    
            const newPrivateState = UserPrivateState {
                ...funderPrivateState,
                contribution: contribution,
                totalAllocation: newAllocation,
            };

            update_user_private_state(newPrivateState, disclosedSaleId); // adds the newPrivateState to existing private state
            
            const userPrivateStateHash = generatePrivateStateHash(newPrivateState, userPk); // we hash the user's private state witht userPk=

            fundingInfo.insert(funder, FundingInfo {
                privateStateHash: userPrivateStateHash, // stores the hash of user's private state for validity check during claim
                claimComplete: false
            });
        
            contractSalesInfo.insert(disclosedSaleId, SaleInfo {
                ...saleInfo,
                amountRaised: saleInfo.amountRaised - disclosedRefundAmount as Uint<64>,
                totalTokenSold: saleInfo.totalTokenSold - (funderPrivateState.totalAllocation - newAllocation),
            });

        } else {
            const sendResult = send(raisedTokenPool, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()), disclosedRefundAmount);
            
            if(sendResult.change.is_some){
                raisedTokenPool.writeCoin(
                    sendResult.change.value,
                    right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
                );
            }else{
                raisedTokenPool.resetToDefault();
            }
            
            remove_sale_from_private_state(disclosedSaleId);
            // fundingInfo.remove(funder);
        }
    }

    export circuit receiveFundsRaised(sale_id: Uint<32>) :[] {
        const disclosedSaleId = disclose(sale_id);
        assert(contractSalesInfo.member(disclosedSaleId), "Sale does not exist");  
        const saleInfo = contractSalesInfo.lookup(disclosedSaleId);
        assert(!saleInfo.hasEnded, "Sale is over can't receive funds yet");
        assert(!saleInfo.hasWithdrawn, "Funds has been withdrawn from this sale");
        assert(raisedTokenPool.value > 0, "No tokens left in this pool");
        assert(saleInfo.amountRaised > 0, "No token raised from this sale");
        const userPk = ownPublicKey().bytes; 
        assert(userPk == organizerPubKey.bytes, "You are not the organizer");

        const sendResult = send(raisedTokenPool, left<ZswapCoinPublicKey, ContractAddress>(organizerPubKey), saleInfo.amountRaised);

        if(sendResult.change.is_some){
            raisedTokenPool.writeCoin(
                sendResult.change.value,
                right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
            );
        }else{
            raisedTokenPool.resetToDefault();
        }
        contractSalesInfo.insert(disclosedSaleId, SaleInfo {
            ...saleInfo,
            hasWithdrawn: true,
        });
    }
}
